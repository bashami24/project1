

HTTP project
Two models:
    Product
        Product Id (must be unique)
        Product Name
        Price
        Seller Name
    Seller
        Seller Name (must be unique)

Create/Read functionality on Seller
    GET /seller/
        - All sellers
    POST /seller/
        - Seller names must be non-null & unique
CRUD functionality on Product
    GET /product/
        - All products
    GET /product/{id}
        - Get a single product
        - We should get a 404 error when we try to access a non-existed product.
    POST /product/ - Add a single product
        - Product ids should be non-null and unique
        - Product names should be non-null
        - Price should be over 0
        - Seller name should refer to an actually existing seller
    PUT /product/{id} - Update a single product
        - Product names should be non-null
        - Price should be over 0
        - Seller name should refer to an actually existing seller
    DELETE /product/{id} - Delete a single product
        - DELETE should always return 200, regardless of if the item existed
            at the start or not. This is convention.



import org.example.DAO.BookDAO;
import org.example.DAO.SellerDAO;
import org.example.Exceptions.*;
import org.example.Model.Book;
import org.example.Model.Seller;
import org.example.Service.BookService;
import org.example.Service.SellerService;
import org.junit.Before;
import org.junit.Test;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

public class ServiceTest {

    private BookDAO bookDAO;
    private SellerDAO sellerDAO;
    private BookService bookService;
    private SellerService sellerService;

    @Before
    public void setUp() {
        bookDAO = new MockBookDAO();
        sellerDAO = new MockSellerDAO();
        bookService = new BookService(bookDAO);
        sellerService = new SellerService(sellerDAO);
    }

    @Test
    public void testSaveBook() throws BookAlreadyExistsException, BookNotFoundException {
        Book book = new Book(1, "Book1", 10.0);
        bookService.saveBook(book);
        assertNotNull(bookDAO.getBookById(1));
    }

    @Test(expected = BookAlreadyExistsException.class)
    public void testSaveBookAlreadyExists() throws BookAlreadyExistsException, BookNotFoundException {
        Book book = new Book(1, "Book1", 10.0);
        bookService.saveBook(book);
        bookService.saveBook(book);
    }

    @Test(expected = BookNotFoundException.class)
    public void testSaveBookInvalidName() throws BookAlreadyExistsException, BookNotFoundException {
        Book book = new Book(1, "", 10.0);
        bookService.saveBook(book);
    }

    @Test
    public void testGetAllBooks() {
        List<Book> books = new ArrayList<>();
        books.add(new Book(1, "Book1", 10.0));
        books.add(new Book(2, "Book2", 20.0));
        assertEquals(books.size(), bookService.getAllBooks().size());
    }

    @Test
    public void testGetSellerById() throws SellerNotFoundException {
        Seller seller = new Seller(1, "Seller1");
        sellerService.saveSeller(seller);
        assertEquals(seller, sellerService.getSellerById(1));
    }

    // Similarly, you can write tests for other methods in BookService and SellerService

    private class MockBookDAO implements BookDAO {
        private List<Book> books = new ArrayList<>();

        @Override
        public void insertBook(Book book) throws SQLException {
            books.add(book);
        }

        @Override
        public List<Book> getAllBooks() {
            return books;
        }

        @Override
        public Book getBookById(int id) {
            for (Book book : books) {
                if (book.getId() == id) {
                    return book;
                }
            }
            return null;
        }

        @Override
        public void updateBook(int id, Book updatedBook) {
            for (int i = 0; i < books.size(); i++) {
                if (books.get(i).getId() == id) {
                    books.set(i, updatedBook);
                    break;
                }
            }
        }

        @Override
        public void deleteBook(int id) {
            books.removeIf(book -> book.getId() == id);
        }
    }

    private class MockSellerDAO implements SellerDAO {
        private List<Seller> sellers = new ArrayList<>();

        @Override
        public void insertSeller(Seller seller) {
            sellers.add(seller);
        }

        @Override
        public List<Seller> getAllSellers() {
            return sellers;
        }

        @Override
        public Seller getSellerById(int id) {
            for (Seller seller : sellers) {
                if (seller.getId() == id) {
                    return seller;
                }
            }
            return null;
        }

        @Override
        public void updateSeller(int id, Seller updatedSeller) {
            for (int i = 0; i < sellers.size(); i++) {
                if (sellers.get(i).getId() == id) {
                    sellers.set(i, updatedSeller);
                    break;
                }
            }
        }

        @Override
        public void deleteSeller(int id) {
            sellers.removeIf(seller -> seller.getId() == id);
        }
    }
}
