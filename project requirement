HTTP project
Two models:
    Product
        Product Id (must be unique)
        Product Name
        Price
        Seller Name
    Seller
        Seller Name (must be unique)

Create/Read functionality on Seller
    GET /seller/
        - All sellers
    POST /seller/
        - Seller names must be non-null & unique
CRUD functionality on Product
    GET /product/
        - All products
    GET /product/{id}
        - Get a single product
        - We should get a 404 error when we try to access a non-existed product.
    POST /product/ - Add a single product
        - Product ids should be non-null and unique
        - Product names should be non-null
        - Price should be over 0
        - Seller name should refer to an actually existing seller
    PUT /product/{id} - Update a single product
        - Product names should be non-null
        - Price should be over 0
        - Seller name should refer to an actually existing seller
    DELETE /product/{id} - Delete a single product
        - DELETE should always return 200, regardless of if the item existed
            at the start or not. This is convention.

Unit testing of service classes
Logging within service classes

Sure, let's adapt the project to work with books and authors instead. We'll need to adjust the model classes, service classes, controller classes, and the main class accordingly. Here's how we can do it:

### Model Classes

```java
// Author.java
package org.example.model;

import java.util.Objects;

public class Author {
    private String name;

    public Author() {
    }

    public Author(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Author author = (Author) o;
        return Objects.equals(name, author.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    @Override
    public String toString() {
        return "Author{" +
                "name='" + name + '\'' +
                '}';
    }
}

package org.example.service;

import org.example.model.Author;
import org.example.exception.AuthorNotFoundException;

import java.util.ArrayList;
import java.util.List;

public class AuthorService {

    private final List<Author> authorList;

    public AuthorService() {
        this.authorList = new ArrayList<>();
    }

    public List<Author> getAllAuthors() {
        return authorList;
    }

    public void addAuthor(Author author) {
        authorList.add(author);
    }

    public Author getAuthorByName(String name) throws AuthorNotFoundException {
        for (Author author : authorList) {
            if (author.getName().equals(name)) {
                return author;
            }
        }
        throw new AuthorNotFoundException("Author not found with name: " + name);
    }

    public void updateAuthor(String name, Author updatedAuthor) throws AuthorNotFoundException {
        boolean found = false;
        for (int i = 0; i < authorList.size(); i++) {
            Author author = authorList.get(i);
            if (author.getName().equals(name)) {
                authorList.set(i, updatedAuthor);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new AuthorNotFoundException("Author not found with name: " + name);
        }
    }

    public void deleteAuthor(String name) throws AuthorNotFoundException {
        boolean removed = authorList.removeIf(author -> author.getName().equals(name));
        if (!removed) {
            throw new AuthorNotFoundException("Author not found with name: " + name);
        }
    }
}

//////////////////////
package org.example.service;

import org.example.model.Book;
import org.example.exception.BookNotFoundException;

import java.util.ArrayList;
import java.util.List;

public class BookService {

    private final List<Book> bookList;

    public BookService() {
        this.bookList = new ArrayList<>();
    }

    public List<Book> getAllBooks() {
        return bookList;
    }

    public void addBook(Book book) {
        bookList.add(book);
    }

    public Book getBookById(long id) throws BookNotFoundException {
        for (Book book : bookList) {
            if (book.getId() == id) {
                return book;
            }
        }
        throw new BookNotFoundException("Book not found with id: " + id);
    }

    public void updateBook(long id, Book updatedBook) throws BookNotFoundException {
        boolean found = false;
        for (int i = 0; i < bookList.size(); i++) {
            Book book = bookList.get(i);
            if (book.getId() == id) {
                bookList.set(i, updatedBook);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new BookNotFoundException("Book not found with id: " + id);
        }
    }

    public void deleteBook(long id) throws BookNotFoundException {
        boolean removed = bookList.removeIf(book -> book.getId() == id);
        if (!removed) {
            throw new BookNotFoundException("Book not found with id: " + id);
        }
    }
}
////////////
package org.example.Controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.javalin.Javalin;
import org.example.Exception.PaintingException;
import org.example.Model.Author;
import org.example.Model.Painting;
import org.example.Service.AuthorService;
import org.example.Service.PaintingService;

import java.util.List;

public class ArtController {

    AuthorService authorService;
    PaintingService paintingService;

    public ArtController(AuthorService authorService, PaintingService paintingService){
        this.authorService = authorService;
        this.paintingService = paintingService;
    }

    public Javalin getAPI(){
        Javalin api = Javalin.create();

        api.get("health", context -> {context.result("Server is UP");});
//        a get for both author and painting
//        a post for both author and painting
//        I'll showcase a endpoint that requires usage of both the author and painting service
//        I'll showcase exception handling within the controller
//        Test case/logging
        api.get("author", context -> {
            List<Author> authorList = authorService.getAuthorList();
            context.json(authorList);
        });
        api.get("painting", context -> {
            List<Painting> paintingList = paintingService.getPaintingList();
            context.json(paintingList);
        });
        api.post("author", context -> {
            try{
                ObjectMapper om = new ObjectMapper();
                Author a = om.readValue(context.body(), Author.class);
                authorService.addAuthor(a);
                context.status(201);
            }catch(JsonProcessingException e){
                context.status(400);
            }
        });
        api.post("painting", context -> {
            try{
                ObjectMapper om = new ObjectMapper();
                Painting p = om.readValue(context.body(), Painting.class);
                Painting newPainting = paintingService.addPainting(p);
                context.status(201);
                context.json(newPainting);
            }catch(JsonProcessingException e){
                context.status(400);
            }catch(PaintingException e){
                context.result(e.getMessage());
                context.status(400);
            }
        });
        /**
         * case 1: the painting id is found
         *  - respond with the painting JSON status 200
         *  case 2: the painting is not found
         *  - respond with no body status 404
         */
        api.get("painting/{id}", context -> {
            long id = Long.parseLong(context.pathParam("id"));
           Painting p = paintingService.getPaintingById(id);
           if(p == null){
               context.status(404);
           }else{
               context.json(p);
               context.status(200);
           }
        });

        return api;
    }
