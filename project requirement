

HTTP project
Two models:
    Product
        Product Id (must be unique)
        Product Name
        Price
        Seller Name
    Seller
        Seller Name (must be unique)

Create/Read functionality on Seller
    GET /seller/
        - All sellers
    POST /seller/
        - Seller names must be non-null & unique
CRUD functionality on Product
    GET /product/
        - All products
    GET /product/{id}
        - Get a single product
        - We should get a 404 error when we try to access a non-existed product.
    POST /product/ - Add a single product
        - Product ids should be non-null and unique
        - Product names should be non-null
        - Price should be over 0
        - Seller name should refer to an actually existing seller
    PUT /product/{id} - Update a single product
        - Product names should be non-null
        - Price should be over 0
        - Seller name should refer to an actually existing seller
    DELETE /product/{id} - Delete a single product
        - DELETE should always return 200, regardless of if the item existed
            at the start or not. This is convention.


public class BookService {
    BookDAO bookDAO;

    public BookService(BookDAO bookDAO) {
        this.bookDAO = bookDAO;
    }

    public void saveBook(Book b) throws BookAlreadyExistsException, InvalidBookException {
        if (b.getId() <= 0) {
            throw new InvalidBookException("Book ID must be greater than 0");
        }

        if (bookDAO.getBookById(b.getId()) != null) {
            throw new BookAlreadyExistsException("Book with ID " + b.getId() + " already exists");
        }

        if (b.getName() == null || b.getName().isEmpty()) {
            throw new InvalidBookException("Book name cannot be null or empty");
        }

        if (b.getPrice() <= 0) {
            throw new InvalidBookException("Book price must be greater than 0");
        }

        bookDAO.insertBook(b);
    }

    public List<Book> getAllBooks() {
        return bookDAO.getAllBooks();
    }

    public void updateBook(int id, Book updatedBook) throws SQLException, BookNotFoundException, InvalidBookException {
        if (updatedBook.getName() == null || updatedBook.getName().isEmpty()) {
            throw new InvalidBookException("Book name cannot be null or empty");
        }

        if (updatedBook.getPrice() <= 0) {
            throw new InvalidBookException("Book price must be greater than 0");
        }

        Book existingBook = bookDAO.getBookById(id);
        if (existingBook == null) {
            throw new BookNotFoundException("Book with ID " + id + " not found");
        }

        bookDAO.updateBook(id, updatedBook);
    }

    public void deleteBook(int bookId) throws SQLException, BookNotFoundException {
        Book existingBook = bookDAO.getBookById(bookId);
        if (existingBook == null) {
            throw new BookNotFoundException("Book with ID " + bookId + " not found");
        }

        bookDAO.deleteBook(bookId);
    }
}
public class SellerService {
    SellerDAO sellerDAO;

    public SellerService(SellerDAO sellerDAO) {
        this.sellerDAO = sellerDAO;
    }

    public void saveSeller(Seller s) throws SellerAlreadyExistsException, InvalidSellerException {
        if (s.getId() <= 0) {
            throw new InvalidSellerException("Seller ID must be greater than 0");
        }

        if (sellerDAO.getSellerById(s.getId()) != null) {
            throw new SellerAlreadyExistsException("Seller with ID " + s.getId() + " already exists");
        }

        if (s.getName() == null || s.getName().isEmpty()) {
            throw new InvalidSellerException("Seller name cannot be null or empty");
        }

        sellerDAO.insertSeller(s);
    }

    public List<Seller> getAllSellers() {
        return sellerDAO.getAllSellers();
    }

    public Seller getSellerById(int id) throws SellerNotFoundException {
        Seller seller = sellerDAO.getSellerById(id);
        if (seller == null) {
            throw new SellerNotFoundException("Seller with ID " + id + " not found");
        }
        return seller;
    }
}
